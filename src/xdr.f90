MODULE XDR

  USE, INTRINSIC :: ISO_C_BINDING
  IMPLICIT NONE
  PRIVATE

  TYPE, PUBLIC :: XDR_T
      CHARACTER(KIND = C_CHAR, LEN = :), POINTER, PRIVATE :: BUFFER
      INTEGER(KIND = C_SIZE_T), PRIVATE :: OFFSET
      INTEGER(KIND = C_SIZE_T), PUBLIC :: SIZE
      LOGICAL, PRIVATE :: OWNS_BUFFER
    CONTAINS
      GENERIC, PUBLIC :: CREATE => XDR_CREATE_DATA, XDR_CREATE_SIZE
      PROCEDURE, PRIVATE :: XDR_CREATE_DATA
      PROCEDURE, PRIVATE :: XDR_CREATE_SIZE

      PROCEDURE, PUBLIC :: READ_FILE => XDR_READ_FILE
      PROCEDURE, PUBLIC :: WRITE_FILE => XDR_WRITE_FILE

      PROCEDURE, PUBLIC :: DESTROY => XDR_DESTROY

      PROCEDURE, PUBLIC :: GETPOS => XDR_GETPOS
      PROCEDURE, PUBLIC :: SETPOS => XDR_SETPOS

      GENERIC, PUBLIC :: GET => &
          XDR_GET_VOID, XDR_GET_LOGICAL, &
          XDR_GET_INT8, XDR_GET_INT16, &
          XDR_GET_INT32, XDR_GET_INT64, &
          XDR_GET_FLOAT, XDR_GET_DOUBLE, &
          XDR_GET_BYTES, XDR_GET_STRING
      PROCEDURE, PRIVATE :: XDR_GET_VOID
      PROCEDURE, PRIVATE :: XDR_GET_LOGICAL
      PROCEDURE, PRIVATE :: XDR_GET_INT8
      PROCEDURE, PRIVATE :: XDR_GET_INT16
      PROCEDURE, PRIVATE :: XDR_GET_INT32
      PROCEDURE, PRIVATE :: XDR_GET_INT64
      PROCEDURE, PRIVATE :: XDR_GET_FLOAT
      PROCEDURE, PRIVATE :: XDR_GET_DOUBLE
      PROCEDURE, PRIVATE :: XDR_GET_BYTES
      PROCEDURE, PRIVATE :: XDR_GET_STRING

      PROCEDURE, PUBLIC :: GET_CHARACTER => XDR_GET_CHARACTER

      GENERIC, PUBLIC :: GET_UNSIGNED => &
          XDR_GET_UINT8, &
          XDR_GET_UINT16, &
          XDR_GET_UINT32
      PROCEDURE, PRIVATE :: XDR_GET_UINT8
      PROCEDURE, PRIVATE :: XDR_GET_UINT16
      PROCEDURE, PRIVATE :: XDR_GET_UINT32

      GENERIC, PUBLIC :: GET_VECTOR => &
          XDR_GET_LOGICAL_VECTOR, &
          XDR_GET_INT8_VECTOR, XDR_GET_INT16_VECTOR, &
          XDR_GET_INT32_VECTOR, XDR_GET_INT64_VECTOR, &
          XDR_GET_FLOAT_VECTOR, XDR_GET_DOUBLE_VECTOR, &
          XDR_GET_BYTES_VECTOR, XDR_GET_STRING_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_LOGICAL_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_INT8_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_INT16_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_INT32_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_INT64_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_FLOAT_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_DOUBLE_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_BYTES_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_STRING_VECTOR

      PROCEDURE, PUBLIC :: GET_CHARACTER_VECTOR => XDR_GET_CHARACTER_VECTOR

      GENERIC, PUBLIC :: GET_UNSIGNED_VECTOR => &
          XDR_GET_UINT8_VECTOR, &
          XDR_GET_UINT16_VECTOR, &
          XDR_GET_UINT32_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_UINT8_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_UINT16_VECTOR
      PROCEDURE, PRIVATE :: XDR_GET_UINT32_VECTOR

      GENERIC, PUBLIC :: GET_ARRAY => &
          XDR_GET_LOGICAL_ARRAY, &
          XDR_GET_INT8_ARRAY, XDR_GET_INT16_ARRAY, &
          XDR_GET_INT32_ARRAY, XDR_GET_INT64_ARRAY, &
          XDR_GET_FLOAT_ARRAY, XDR_GET_DOUBLE_ARRAY, &
          XDR_GET_BYTES_ARRAY, XDR_GET_STRING_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_LOGICAL_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_INT8_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_INT16_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_INT32_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_INT64_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_FLOAT_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_DOUBLE_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_BYTES_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_STRING_ARRAY

      PROCEDURE, PUBLIC :: GET_CHARACTER_ARRAY => XDR_GET_CHARACTER_ARRAY

      GENERIC, PUBLIC :: GET_UNSIGNED_ARRAY => &
          XDR_GET_UINT8_ARRAY, &
          XDR_GET_UINT16_ARRAY, &
          XDR_GET_UINT32_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_UINT8_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_UINT16_ARRAY
      PROCEDURE, PRIVATE :: XDR_GET_UINT32_ARRAY

      GENERIC, PUBLIC :: PUT => &
          XDR_PUT_VOID, XDR_PUT_LOGICAL, &
          XDR_PUT_INT8, XDR_PUT_INT16, &
          XDR_PUT_INT32, XDR_PUT_INT64, &
          XDR_PUT_FLOAT, XDR_PUT_DOUBLE, &
          XDR_PUT_BYTES, XDR_PUT_STRING
      PROCEDURE, PRIVATE :: XDR_PUT_VOID
      PROCEDURE, PRIVATE :: XDR_PUT_LOGICAL
      PROCEDURE, PRIVATE :: XDR_PUT_INT8
      PROCEDURE, PRIVATE :: XDR_PUT_INT16
      PROCEDURE, PRIVATE :: XDR_PUT_INT32
      PROCEDURE, PRIVATE :: XDR_PUT_INT64
      PROCEDURE, PRIVATE :: XDR_PUT_FLOAT
      PROCEDURE, PRIVATE :: XDR_PUT_DOUBLE
      PROCEDURE, PRIVATE :: XDR_PUT_BYTES
      PROCEDURE, PRIVATE :: XDR_PUT_STRING

      PROCEDURE, PUBLIC :: PUT_CHARACTER => XDR_PUT_CHARACTER

      GENERIC, PUBLIC :: PUT_UNSIGNED => &
          XDR_PUT_UINT8, &
          XDR_PUT_UINT16, &
          XDR_PUT_UINT32
      PROCEDURE, PRIVATE :: XDR_PUT_UINT8
      PROCEDURE, PRIVATE :: XDR_PUT_UINT16
      PROCEDURE, PRIVATE :: XDR_PUT_UINT32

      GENERIC, PUBLIC :: PUT_VECTOR => &
          XDR_PUT_LOGICAL_VECTOR, &
          XDR_PUT_INT8_VECTOR, XDR_PUT_INT16_VECTOR, &
          XDR_PUT_INT32_VECTOR, XDR_PUT_INT64_VECTOR, &
          XDR_PUT_FLOAT_VECTOR, XDR_PUT_DOUBLE_VECTOR, &
          XDR_PUT_BYTES_VECTOR, XDR_PUT_STRING_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_LOGICAL_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_INT8_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_INT16_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_INT32_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_INT64_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_FLOAT_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_DOUBLE_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_BYTES_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_STRING_VECTOR

      PROCEDURE, PUBLIC :: PUT_CHARACTER_VECTOR => XDR_PUT_CHARACTER_VECTOR

      GENERIC, PUBLIC :: PUT_UNSIGNED_VECTOR => &
          XDR_PUT_UINT8_VECTOR, &
          XDR_PUT_UINT16_VECTOR, &
          XDR_PUT_UINT32_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_UINT8_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_UINT16_VECTOR
      PROCEDURE, PRIVATE :: XDR_PUT_UINT32_VECTOR

      GENERIC, PUBLIC :: PUT_ARRAY => &
          XDR_PUT_LOGICAL_ARRAY, &
          XDR_PUT_INT8_ARRAY, XDR_PUT_INT16_ARRAY, &
          XDR_PUT_INT32_ARRAY, XDR_PUT_INT64_ARRAY, &
          XDR_PUT_FLOAT_ARRAY, XDR_PUT_DOUBLE_ARRAY, &
          XDR_PUT_BYTES_ARRAY, XDR_PUT_STRING_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_LOGICAL_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_INT8_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_INT16_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_INT32_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_INT64_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_FLOAT_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_DOUBLE_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_BYTES_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_STRING_ARRAY

      PROCEDURE, PUBLIC :: PUT_CHARACTER_ARRAY => XDR_PUT_CHARACTER_ARRAY

      GENERIC, PUBLIC :: PUT_UNSIGNED_ARRAY => &
          XDR_PUT_UINT8_ARRAY, &
          XDR_PUT_UINT16_ARRAY, &
          XDR_PUT_UINT32_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_UINT8_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_UINT16_ARRAY
      PROCEDURE, PRIVATE :: XDR_PUT_UINT32_ARRAY
  END TYPE

  CHARACTER(KIND = C_CHAR, LEN = 3), PARAMETER :: PADDING = REPEAT(C_NULL_CHAR, 3)

  INTERFACE

    FUNCTION FILE_SIZE(FILENAME) RESULT(NBYTES) BIND(C)
      USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_CHAR, C_LONG
      IMPLICIT NONE
      CHARACTER(KIND = C_CHAR), DIMENSION(*), INTENT(IN) :: FILENAME
      INTEGER(KIND = C_LONG) :: NBYTES
    END FUNCTION

    FUNCTION DOWNCAST_UINT32_T(X) RESULT(Y) BIND(C)
      USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_INT32_T, C_INT64_T
      IMPLICIT NONE
      INTEGER(KIND = C_INT64_T), VALUE, INTENT(IN) :: X
      INTEGER(KIND = C_INT32_T) :: Y
    END FUNCTION

    FUNCTION UPCAST_UINT32_T(X) RESULT(Y) BIND(C)
      USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_INT32_T, C_INT64_T
      IMPLICIT NONE
      INTEGER(KIND = C_INT32_T), VALUE, INTENT(IN) :: X
      INTEGER(KIND = C_INT64_T) :: Y
    END FUNCTION

  END INTERFACE

CONTAINS

  PURE FUNCTION BSWAP_INT32_T(X) RESULT(Y)
    USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_INT32_T
    IMPLICIT NONE
    INTEGER(KIND = C_INT32_T), VALUE, INTENT(IN) :: X
    INTEGER(KIND = C_INT32_T) :: Y

    CHARACTER(LEN = 4) :: BYTES_COPY
    CHARACTER(LEN = 4) :: BYTES_SWAP

    BYTES_COPY = TRANSFER(X, BYTES_COPY)
    BYTES_SWAP(1:1) = BYTES_COPY(4:4)
    BYTES_SWAP(2:2) = BYTES_COPY(3:3)
    BYTES_SWAP(3:3) = BYTES_COPY(2:2)
    BYTES_SWAP(4:4) = BYTES_COPY(1:1)
    Y = TRANSFER(BYTES_SWAP, Y)
  END FUNCTION

  PURE FUNCTION BSWAP_INT64_T(X) RESULT(Y)
    USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_INT64_T
    IMPLICIT NONE
    INTEGER(KIND = C_INT64_T), VALUE, INTENT(IN) :: X
    INTEGER(KIND = C_INT64_T) :: Y

    CHARACTER(LEN = 8) :: BYTES_COPY
    CHARACTER(LEN = 8) :: BYTES_SWAP

    BYTES_COPY = TRANSFER(X, BYTES_COPY)
    BYTES_SWAP(1:1) = BYTES_COPY(8:8)
    BYTES_SWAP(2:2) = BYTES_COPY(7:7)
    BYTES_SWAP(3:3) = BYTES_COPY(6:6)
    BYTES_SWAP(4:4) = BYTES_COPY(5:5)
    BYTES_SWAP(5:5) = BYTES_COPY(4:4)
    BYTES_SWAP(6:6) = BYTES_COPY(3:3)
    BYTES_SWAP(7:7) = BYTES_COPY(2:2)
    BYTES_SWAP(8:8) = BYTES_COPY(1:1)
    Y = TRANSFER(BYTES_SWAP, Y)
  END FUNCTION

  PURE FUNCTION BSWAP_FLOAT(X) RESULT(Y)
    USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_FLOAT
    IMPLICIT NONE
    REAL(KIND = C_FLOAT), VALUE, INTENT(IN) :: X
    REAL(KIND = C_FLOAT) :: Y

    CHARACTER(LEN = 4) :: BYTES_COPY
    CHARACTER(LEN = 4) :: BYTES_SWAP

    BYTES_COPY = TRANSFER(X, BYTES_COPY)
    BYTES_SWAP(1:1) = BYTES_COPY(4:4)
    BYTES_SWAP(2:2) = BYTES_COPY(3:3)
    BYTES_SWAP(3:3) = BYTES_COPY(2:2)
    BYTES_SWAP(4:4) = BYTES_COPY(1:1)
    Y = TRANSFER(BYTES_SWAP, Y)
  END FUNCTION

  PURE FUNCTION BSWAP_DOUBLE(X) RESULT(Y)
    USE, INTRINSIC :: ISO_C_BINDING, ONLY : C_INT64_T
    IMPLICIT NONE
    REAL(KIND = C_DOUBLE), VALUE, INTENT(IN) :: X
    REAL(KIND = C_DOUBLE) :: Y

    CHARACTER(LEN = 8) :: BYTES_COPY
    CHARACTER(LEN = 8) :: BYTES_SWAP

    BYTES_COPY = TRANSFER(X, BYTES_COPY)
    BYTES_SWAP(1:1) = BYTES_COPY(8:8)
    BYTES_SWAP(2:2) = BYTES_COPY(7:7)
    BYTES_SWAP(3:3) = BYTES_COPY(6:6)
    BYTES_SWAP(4:4) = BYTES_COPY(5:5)
    BYTES_SWAP(5:5) = BYTES_COPY(4:4)
    BYTES_SWAP(6:6) = BYTES_COPY(3:3)
    BYTES_SWAP(7:7) = BYTES_COPY(2:2)
    BYTES_SWAP(8:8) = BYTES_COPY(1:1)
    Y = TRANSFER(BYTES_SWAP, Y)
  END FUNCTION

  SUBROUTINE XDR_ALLOCATE_STRINGS(SIZE, LENGTH, STRS)
    INTEGER(KIND = C_INT32_T), INTENT(IN) :: SIZE
    INTEGER, INTENT(IN) :: LENGTH
    CHARACTER(KIND = C_CHAR, LEN = LENGTH), DIMENSION(:), ALLOCATABLE :: STRS

    ALLOCATE(CHARACTER(LEN = LENGTH) :: STRS(SIZE))
  END SUBROUTINE

  FUNCTION XDR_BLOCK_SIZE(N) RESULT(SIZE)
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: N
    INTEGER(KIND = C_SIZE_T) :: SIZE

    SIZE = IAND(N + 3, NOT(3))
  END FUNCTION

  SUBROUTINE XDR_CREATE_DATA(SELF, BUFFER, SIZE)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER, INTENT(IN) :: BUFFER
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE

    SELF%OFFSET = 1
    SELF%SIZE = SIZE
    SELF%BUFFER => BUFFER
    SELF%OWNS_BUFFER = .FALSE.
  END SUBROUTINE

  SUBROUTINE XDR_CREATE_SIZE(SELF, SIZE)
    CLASS(XDR_T) :: SELF
    INTEGER, INTENT(IN) :: SIZE

    SELF%OFFSET = 1
    SELF%SIZE = SIZE
    ALLOCATE(CHARACTER(KIND = C_CHAR, LEN = SIZE) :: SELF%BUFFER)
    SELF%OWNS_BUFFER = .TRUE.
  END SUBROUTINE

  SUBROUTINE XDR_READ_FILE(SELF, FILENAME)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), INTENT(IN) :: FILENAME

    INTEGER :: LENGTH

    SELF%OFFSET = 1
    LENGTH = LEN_TRIM(FILENAME)
    IF (FILENAME(LENGTH:LENGTH) == C_NULL_CHAR) THEN
      SELF%SIZE = FILE_SIZE(TRIM(FILENAME))
      OPEN(UNIT = 21, &
           FILE = FILENAME(1:LENGTH-1), &
           FORM = 'UNFORMATTED', &
           ACCESS = 'STREAM')
    ELSE
      SELF%SIZE = FILE_SIZE(TRIM(FILENAME) // C_NULL_CHAR)
      OPEN(UNIT = 21, FILE = FILENAME, FORM = 'UNFORMATTED', ACCESS = 'STREAM')
    END IF
    ALLOCATE(CHARACTER(KIND = C_CHAR, LEN = SELF%SIZE) :: SELF%BUFFER)
    READ(21) SELF%BUFFER
    CLOSE(UNIT = 21)
    SELF%OWNS_BUFFER = .TRUE.
  END SUBROUTINE

  SUBROUTINE XDR_WRITE_FILE(SELF, FILENAME)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), INTENT(IN) :: FILENAME

    OPEN(UNIT = 21, FILE = FILENAME, FORM = 'UNFORMATTED', ACCESS = 'STREAM')
    WRITE(21) SELF%BUFFER
    CLOSE(UNIT = 21)
  END SUBROUTINE

  SUBROUTINE XDR_DESTROY(SELF)
    CLASS(XDR_T) :: SELF

    SELF%OFFSET = 0
    SELF%SIZE = 0
    IF (SELF%OWNS_BUFFER) THEN
      DEALLOCATE(SELF%BUFFER)
    ELSE
      NULLIFY(SELF%BUFFER)
    END IF
    SELF%OWNS_BUFFER = .FALSE.
  END SUBROUTINE

  FUNCTION XDR_GETPOS(SELF) RESULT(POS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_SIZE_T) :: POS

    POS = SELF%OFFSET
  END FUNCTION

  FUNCTION XDR_SETPOS(SELF, POS) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_SIZE_T) :: POS
    LOGICAL :: SUCCESS

    IF (POS <= (SELF%SIZE + 1) .AND. MOD(POS, 4) == 1) THEN
      SELF%OFFSET = POS
      SUCCESS = .TRUE.
    ELSE
      SUCCESS = .FALSE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_VOID(SELF) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL :: SUCCESS

    SUCCESS = .TRUE.
  END FUNCTION

  FUNCTION XDR_GET_LOGICAL(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL, INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    SUCCESS = XDR_GET_INT32(SELF, X)
    IF (X == 0) THEN
      VAL = .FALSE.
    ELSE IF (X == 1) THEN
      VAL = .TRUE.
    ELSE
      SUCCESS = .FALSE.
      SELF%OFFSET = SELF%OFFSET - C_SIZEOF(X)
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT8(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT8_T), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    SUCCESS = XDR_GET_INT32(SELF, X)
    VAL = INT(X, KIND = C_INT8_T)
  END FUNCTION

  FUNCTION XDR_GET_INT16(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    SUCCESS = XDR_GET_INT32(SELF, X)
    VAL = INT(X, KIND = C_INT16_T)
  END FUNCTION

  FUNCTION XDR_GET_INT32(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      VAL = TRANSFER(SELF%BUFFER(SELF%OFFSET:E), VAL)
      VAL = BSWAP_INT32_T(VAL)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT64(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      VAL = TRANSFER(SELF%BUFFER(SELF%OFFSET:E), VAL)
      VAL = BSWAP_INT64_T(VAL)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_FLOAT(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_FLOAT), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      VAL = TRANSFER(SELF%BUFFER(SELF%OFFSET:E), VAL)
      VAL = BSWAP_FLOAT(VAL)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_DOUBLE(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_DOUBLE), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      VAL = TRANSFER(SELF%BUFFER(SELF%OFFSET:E), VAL)
      VAL = BSWAP_DOUBLE(VAL)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_BYTES(SELF, STR, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), INTENT(INOUT) :: STR
    INTEGER(KIND = C_SIZE_T), INTENT(OUT) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_INT32_T) :: LENGTH

    SUCCESS = XDR_GET_INT32(SELF, LENGTH)
    SIZE = INT(LENGTH, C_SIZE_T)
    E = SELF%OFFSET + SIZE - 1
    IF (SUCCESS .AND. E <= SELF%SIZE) THEN
      E = SELF%OFFSET + MIN(SIZE, LEN(STR)) - 1
      STR = SELF%BUFFER(SELF%OFFSET:E)
      SELF%OFFSET = SELF%OFFSET + XDR_BLOCK_SIZE(INT(SIZE, KIND = C_SIZE_T))
    END IF
  END FUNCTION

  FUNCTION XDR_GET_STRING(SELF, STR) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), INTENT(INOUT) :: STR
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: SIZE

    SUCCESS = XDR_GET_BYTES(SELF, STR, SIZE)
  END FUNCTION

  FUNCTION XDR_GET_CHARACTER(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    SUCCESS = XDR_GET_INT32(SELF, X)
    VAL = CHAR(X)
  END FUNCTION

  FUNCTION XDR_GET_UINT8(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT64_T) :: X

    SUCCESS = XDR_GET_UINT32(SELF, X)
    VAL = INT(X, KIND = C_INT16_T)
  END FUNCTION

  FUNCTION XDR_GET_UINT16(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT64_T) :: X

    SUCCESS = XDR_GET_UINT32(SELF, X)
    VAL = INT(X, KIND = C_INT32_T)
  END FUNCTION

  FUNCTION XDR_GET_UINT32(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), INTENT(OUT) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_INT32_T) :: X

    E = SELF%OFFSET + C_SIZEOF(X) - 1
    IF (E > SELF%SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      X = TRANSFER(SELF%BUFFER(SELF%OFFSET:E), X)
      VAL = UPCAST_UINT32_T(BSWAP_INT32_T(x))
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_GET_LOGICAL_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL, DIMENSION(:), INTENT(INOUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_GET_LOGICAL(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_GET_INT8_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT8_T), DIMENSION(:), INTENT(INOUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_GET_INT8(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_GET_INT16_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), INTENT(INOUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_GET_INT16(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_GET_INT32_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), INTENT(INOUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_GET_INT32(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_GET_INT64_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), INTENT(INOUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_GET_INT64(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_GET_FLOAT_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_FLOAT), DIMENSION(:), INTENT(INOUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_GET_FLOAT(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_GET_DOUBLE_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_DOUBLE), DIMENSION(:), INTENT(INOUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_GET_DOUBLE(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_GET_BYTES_VECTOR(SELF, STRS, LENGTHS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), INTENT(INOUT) :: STRS
    INTEGER(KIND = C_SIZE_T), DIMENSION(:), INTENT(OUT) :: LENGTHS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_GET_BYTES(SELF, STRS(N), LENGTHS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_GET_STRING_VECTOR(SELF, STRS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), INTENT(INOUT) :: STRS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_GET_STRING(SELF, STRS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_GET_CHARACTER_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR), DIMENSION(:), INTENT(INOUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_GET_CHARACTER(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_GET_UINT8_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), INTENT(INOUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_GET_UINT8(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_GET_UINT16_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), INTENT(INOUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_GET_UINT16(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_GET_UINT32_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), INTENT(INOUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_GET_UINT32(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_GET_LOGICAL_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL, DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: SIZE
    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    SUCCESS = XDR_GET_INT32(SELF, SIZE)
    IF (SUCCESS .AND. INT(SIZE, KIND = C_SIZE_T) <= MAXSIZE) THEN
      ALLOCATE(LOGICAL :: VALS(SIZE))
      DO N = 1, SIZE
        SUCCESS = XDR_GET_LOGICAL(SELF, VALS(N))
        IF (.NOT. SUCCESS) THEN
          SELF%OFFSET = B
          EXIT
        END IF
      END DO
    ELSE
      SELF%OFFSET = B
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT8_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT8_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: SIZE
    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    SUCCESS = XDR_GET_INT32(SELF, SIZE)
    IF (SUCCESS .AND. INT(SIZE, KIND = C_SIZE_T) <= MAXSIZE) THEN
      ALLOCATE(INTEGER(KIND = C_INT8_T) :: VALS(SIZE))
      DO N = 1, SIZE
        SUCCESS = XDR_GET_INT8(SELF, VALS(N))
        IF (.NOT. SUCCESS) THEN
          SELF%OFFSET = B
          EXIT
        END IF
      END DO
    ELSE
      SELF%OFFSET = B
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT16_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: SIZE
    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    SUCCESS = XDR_GET_INT32(SELF, SIZE)
    IF (SUCCESS .AND. INT(SIZE, KIND = C_SIZE_T) <= MAXSIZE) THEN
      ALLOCATE(INTEGER(KIND = C_INT16_T) :: VALS(SIZE))
      DO N = 1, SIZE
        SUCCESS = XDR_GET_INT16(SELF, VALS(N))
        IF (.NOT. SUCCESS) THEN
          SELF%OFFSET = B
          EXIT
        END IF
      END DO
    ELSE
      SELF%OFFSET = B
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT32_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: SIZE
    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    SUCCESS = XDR_GET_INT32(SELF, SIZE)
    IF (SUCCESS .AND. INT(SIZE, KIND = C_SIZE_T) <= MAXSIZE) THEN
      ALLOCATE(INTEGER(KIND = C_INT32_T) :: VALS(SIZE))
      DO N = 1, SIZE
        SUCCESS = XDR_GET_INT32(SELF, VALS(N))
        IF (.NOT. SUCCESS) THEN
          SELF%OFFSET = B
          EXIT
        END IF
      END DO
    ELSE
      SELF%OFFSET = B
    END IF
  END FUNCTION

  FUNCTION XDR_GET_INT64_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: SIZE
    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    SUCCESS = XDR_GET_INT32(SELF, SIZE)
    IF (SUCCESS .AND. INT(SIZE, KIND = C_SIZE_T) <= MAXSIZE) THEN
      ALLOCATE(INTEGER(KIND = C_INT64_T) :: VALS(SIZE))
      DO N = 1, SIZE
        SUCCESS = XDR_GET_INT64(SELF, VALS(N))
        IF (.NOT. SUCCESS) THEN
          SELF%OFFSET = B
          EXIT
        END IF
      END DO
    ELSE
      SELF%OFFSET = B
    END IF
  END FUNCTION

  FUNCTION XDR_GET_FLOAT_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_FLOAT), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: SIZE
    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    SUCCESS = XDR_GET_INT32(SELF, SIZE)
    IF (SUCCESS .AND. INT(SIZE, KIND = C_SIZE_T) <= MAXSIZE) THEN
      ALLOCATE(REAL(KIND = C_FLOAT) :: VALS(SIZE))
      DO N = 1, SIZE
        SUCCESS = XDR_GET_FLOAT(SELF, VALS(N))
        IF (.NOT. SUCCESS) THEN
          SELF%OFFSET = B
          EXIT
        END IF
      END DO
    ELSE
      SELF%OFFSET = B
    END IF
  END FUNCTION

  FUNCTION XDR_GET_DOUBLE_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_DOUBLE), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: SIZE
    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    SUCCESS = XDR_GET_INT32(SELF, SIZE)
    IF (SUCCESS .AND. INT(SIZE, KIND = C_SIZE_T) <= MAXSIZE) THEN
      ALLOCATE(REAL(KIND = C_DOUBLE) :: VALS(SIZE))
      DO N = 1, SIZE
        SUCCESS = XDR_GET_DOUBLE(SELF, VALS(N))
        IF (.NOT. SUCCESS) THEN
          SELF%OFFSET = B
          EXIT
        END IF
      END DO
    ELSE
      SELF%OFFSET = B
    END IF
  END FUNCTION

  FUNCTION XDR_GET_BYTES_ARRAY(SELF, STRS, LENGTHS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: STRS
    INTEGER(KIND = C_SIZE_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: LENGTHS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: SIZE
    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    SUCCESS = XDR_GET_INT32(SELF, SIZE)
    IF (SUCCESS .AND. INT(SIZE, KIND = C_SIZE_T) <= MAXSIZE) THEN
      CALL XDR_ALLOCATE_STRINGS(SIZE, LEN(STRS(1)), STRS)
      ALLOCATE(INTEGER(KIND = C_SIZE_T) :: LENGTHS(SIZE))
      DO N = 1, SIZE
        SUCCESS = XDR_GET_BYTES(SELF, STRS(N), LENGTHS(N))
        IF (.NOT. SUCCESS) THEN
          SELF%OFFSET = B
          EXIT
        END IF
      END DO
    ELSE
      SELF%OFFSET = B
    END IF
  END FUNCTION

  FUNCTION XDR_GET_STRING_ARRAY(SELF, STRS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: STRS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: SIZE
    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    SUCCESS = XDR_GET_INT32(SELF, SIZE)
    IF (SUCCESS .AND. INT(SIZE, KIND = C_SIZE_T) <= MAXSIZE) THEN
      CALL XDR_ALLOCATE_STRINGS(SIZE, LEN(STRS(1)), STRS)
      DO N = 1, SIZE
        SUCCESS = XDR_GET_STRING(SELF, STRS(N))
        IF (.NOT. SUCCESS) THEN
          SELF%OFFSET = B
          EXIT
        END IF
      END DO
    ELSE
      SELF%OFFSET = B
    END IF
  END FUNCTION

  FUNCTION XDR_GET_CHARACTER_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: SIZE
    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    SUCCESS = XDR_GET_INT32(SELF, SIZE)
    IF (SUCCESS .AND. INT(SIZE, KIND = C_SIZE_T) <= MAXSIZE) THEN
      ALLOCATE(CHARACTER(KIND = C_CHAR) :: VALS(SIZE))
      DO N = 1, SIZE
        SUCCESS = XDR_GET_CHARACTER(SELF, VALS(N))
        IF (.NOT. SUCCESS) THEN
          SELF%OFFSET = B
          EXIT
        END IF
      END DO
    ELSE
      SELF%OFFSET = B
    END IF
  END FUNCTION

  FUNCTION XDR_GET_UINT8_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: SIZE
    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    SUCCESS = XDR_GET_INT32(SELF, SIZE)
    IF (SUCCESS .AND. INT(SIZE, KIND = C_SIZE_T) <= MAXSIZE) THEN
      ALLOCATE(INTEGER(KIND = C_INT16_T) :: VALS(SIZE))
      DO N = 1, SIZE
        SUCCESS = XDR_GET_UINT8(SELF, VALS(N))
        IF (.NOT. SUCCESS) THEN
          SELF%OFFSET = B
          EXIT
        END IF
      END DO
    ELSE
      SELF%OFFSET = B
    END IF
  END FUNCTION

  FUNCTION XDR_GET_UINT16_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: SIZE
    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    SUCCESS = XDR_GET_INT32(SELF, SIZE)
    IF (SUCCESS .AND. INT(SIZE, KIND = C_SIZE_T) <= MAXSIZE) THEN
      ALLOCATE(INTEGER(KIND = C_INT32_T) :: VALS(SIZE))
      DO N = 1, SIZE
        SUCCESS = XDR_GET_UINT16(SELF, VALS(N))
        IF (.NOT. SUCCESS) THEN
          SELF%OFFSET = B
          EXIT
        END IF
      END DO
    ELSE
      SELF%OFFSET = B
    END IF
  END FUNCTION

  FUNCTION XDR_GET_UINT32_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), ALLOCATABLE, INTENT(OUT) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: SIZE
    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    SUCCESS = XDR_GET_INT32(SELF, SIZE)
    IF (SUCCESS .AND. INT(SIZE, KIND = C_SIZE_T) <= MAXSIZE) THEN
      ALLOCATE(INTEGER(KIND = C_INT64_T) :: VALS(SIZE))
      DO N = 1, SIZE
        SUCCESS = XDR_GET_UINT32(SELF, VALS(N))
        IF (.NOT. SUCCESS) THEN
          SELF%OFFSET = B
          EXIT
        END IF
      END DO
    ELSE
      SELF%OFFSET = B
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_VOID(SELF) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL :: SUCCESS

    SUCCESS = .TRUE.
  END FUNCTION

  FUNCTION XDR_PUT_LOGICAL(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL, INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    IF (VAL) THEN
      SUCCESS = XDR_PUT_INT32(SELF, 1_C_INT32_T)
    ELSE
      SUCCESS = XDR_PUT_INT32(SELF, 0_C_INT32_T)
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_INT8(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT8_T), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    X = INT(VAL, KIND = C_INT32_T)
    SUCCESS = XDR_PUT_INT32(SELF, X)
  END FUNCTION

  FUNCTION XDR_PUT_INT16(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    X = INT(VAL, KIND = C_INT32_T)
    SUCCESS = XDR_PUT_INT32(SELF, X)
  END FUNCTION

  FUNCTION XDR_PUT_INT32(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_INT32_T) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      SWAPPED = BSWAP_INT32_T(VAL)
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_INT64(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_INT64_T) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      SWAPPED = BSWAP_INT64_T(VAL)
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_FLOAT(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_FLOAT), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    REAL(KIND = C_FLOAT) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      SWAPPED = BSWAP_FLOAT(VAL)
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_DOUBLE(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_DOUBLE), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    REAL(KIND = C_DOUBLE) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    E = SELF%OFFSET + C_SIZEOF(VAL) - 1
    IF (E > SELF%SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      SWAPPED = BSWAP_DOUBLE(VAL)
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_BYTES(SELF, STR, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), INTENT(IN) :: STR
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_SIZE_T) :: P
    INTEGER(KIND = C_INT32_T) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    E = SELF%OFFSET + C_SIZEOF(SWAPPED) + XDR_BLOCK_SIZE(SIZE) - 1
    IF (E > SELF%SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      E = SELF%OFFSET + C_SIZEOF(SWAPPED) - 1
      SWAPPED = INT(SIZE, KIND = C_INT32_T)
      SWAPPED = BSWAP_INT32_T(SWAPPED)
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1

      E = SELF%OFFSET + SIZE - 1
      SELF%BUFFER(SELF%OFFSET:E) = STR(1:SIZE)
      SELF%OFFSET = E + 1

      P = XDR_BLOCK_SIZE(SIZE) - SIZE
      E = SELF%OFFSET + P - 1
      SELF%BUFFER(SELF%OFFSET:E) = PADDING(1:P)
      SELF%OFFSET = E + 1

      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_STRING(SELF, STR) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), INTENT(IN) :: STR
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_SIZE_T) :: P
    INTEGER(KIND = C_SIZE_T) :: SIZE
    INTEGER(KIND = C_INT32_T) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    SIZE = LEN(STR)
    E = SELF%OFFSET + C_SIZEOF(SWAPPED) + XDR_BLOCK_SIZE(SIZE) - 1
    IF (E > SELF%SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      E = SELF%OFFSET + C_SIZEOF(SWAPPED) - 1
      SWAPPED = INT(SIZE, KIND = C_INT32_T)
      SWAPPED = BSWAP_INT32_T(SWAPPED)
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1

      E = SELF%OFFSET + SIZE - 1
      SELF%BUFFER(SELF%OFFSET:E) = STR(1:SIZE)
      SELF%OFFSET = E + 1

      P = XDR_BLOCK_SIZE(SIZE) - SIZE
      E = SELF%OFFSET + P - 1
      SELF%BUFFER(SELF%OFFSET:E) = PADDING(1:P)
      SELF%OFFSET = E + 1

      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_CHARACTER(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    X = ICHAR(VAL)
    SUCCESS = XDR_PUT_INT32(SELF, X)
  END FUNCTION

  FUNCTION XDR_PUT_UINT8(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_INT32_T) :: X

    X = INT(VAL, KIND = C_INT32_T)
    SUCCESS = XDR_PUT_UINT16(SELF, X)
  END FUNCTION

  FUNCTION XDR_PUT_UINT16(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_INT32_T) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    E = SELF%OFFSET + C_SIZEOF(SWAPPED) - 1
    IF (E > SELF%SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      SWAPPED = BSWAP_INT32_T(VAL)
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_UINT32(SELF, VAL) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), INTENT(IN) :: VAL
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: E
    INTEGER(KIND = C_INT32_T) :: SWAPPED
    CHARACTER(KIND = C_CHAR, LEN = :), POINTER :: BUFFER

    E = SELF%OFFSET + C_SIZEOF(SWAPPED) - 1
    IF (E > SELF%SIZE) THEN
      SUCCESS = .FALSE.
    ELSE
      SWAPPED = BSWAP_INT32_T(DOWNCAST_UINT32_T(VAL))
      BUFFER => SELF%BUFFER(SELF%OFFSET:E)
      BUFFER = TRANSFER(SWAPPED, BUFFER)
      SELF%OFFSET = E + 1
      SUCCESS = .TRUE.
    END IF
  END FUNCTION

  FUNCTION XDR_PUT_LOGICAL_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL, DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_PUT_LOGICAL(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_INT8_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT8_T), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_PUT_INT8(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_INT16_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_PUT_INT16(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_INT32_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_PUT_INT32(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_INT64_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_PUT_INT64(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_FLOAT_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_FLOAT), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_PUT_FLOAT(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_DOUBLE_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_DOUBLE), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_PUT_DOUBLE(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_BYTES_VECTOR(SELF, STRS, LENGTHS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), INTENT(IN) :: STRS
    INTEGER(KIND = C_SIZE_T), DIMENSION(:), INTENT(IN) :: LENGTHS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_PUT_BYTES(SELF, STRS(N), LENGTHS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_STRING_VECTOR(SELF, STRS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), INTENT(IN) :: STRS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_PUT_STRING(SELF, STRS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_CHARACTER_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_PUT_CHARACTER(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_UINT8_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_PUT_UINT8(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_UINT16_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_PUT_UINT16(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_UINT32_VECTOR(SELF, VALS, SIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: SIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N

    B = SELF%OFFSET
    DO N = 1, SIZE
      SUCCESS = XDR_PUT_UINT32(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_LOGICAL_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    LOGICAL, DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: LENGTH

    B = SELF%OFFSET
    LENGTH = MIN(SIZE(VALS), MAXSIZE)
    SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T))
    DO N = 1, LENGTH
      SUCCESS = XDR_PUT_LOGICAL(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_INT8_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT8_T), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: LENGTH

    B = SELF%OFFSET
    LENGTH = MIN(SIZE(VALS), MAXSIZE)
    SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T))
    DO N = 1, LENGTH
      SUCCESS = XDR_PUT_INT8(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_INT16_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: LENGTH

    B = SELF%OFFSET
    LENGTH = MIN(SIZE(VALS), MAXSIZE)
    SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T))
    DO N = 1, LENGTH
      SUCCESS = XDR_PUT_INT16(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_INT32_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: LENGTH

    B = SELF%OFFSET
    LENGTH = MIN(SIZE(VALS), MAXSIZE)
    SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T))
    DO N = 1, LENGTH
      SUCCESS = XDR_PUT_INT32(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_INT64_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: LENGTH

    B = SELF%OFFSET
    LENGTH = MIN(SIZE(VALS), MAXSIZE)
    SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T))
    DO N = 1, LENGTH
      SUCCESS = XDR_PUT_INT64(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_FLOAT_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_FLOAT), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: LENGTH

    B = SELF%OFFSET
    LENGTH = MIN(SIZE(VALS), MAXSIZE)
    SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T))
    DO N = 1, LENGTH
      SUCCESS = XDR_PUT_FLOAT(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_DOUBLE_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    REAL(KIND = C_DOUBLE), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: LENGTH

    B = SELF%OFFSET
    LENGTH = MIN(SIZE(VALS), MAXSIZE)
    SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T))
    DO N = 1, LENGTH
      SUCCESS = XDR_PUT_DOUBLE(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_CHARACTER_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: LENGTH

    B = SELF%OFFSET
    LENGTH = MIN(SIZE(VALS), MAXSIZE)
    SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T))
    DO N = 1, LENGTH
      SUCCESS = XDR_PUT_CHARACTER(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_UINT8_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT16_T), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: LENGTH

    B = SELF%OFFSET
    LENGTH = MIN(SIZE(VALS), MAXSIZE)
    SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T))
    DO N = 1, LENGTH
      SUCCESS = XDR_PUT_UINT8(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_UINT16_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT32_T), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: LENGTH

    B = SELF%OFFSET
    LENGTH = MIN(SIZE(VALS), MAXSIZE)
    SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T))
    DO N = 1, LENGTH
      SUCCESS = XDR_PUT_UINT16(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_UINT32_ARRAY(SELF, VALS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    INTEGER(KIND = C_INT64_T), DIMENSION(:), INTENT(IN) :: VALS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: LENGTH

    B = SELF%OFFSET
    LENGTH = MIN(SIZE(VALS), MAXSIZE)
    SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T))
    DO N = 1, LENGTH
      SUCCESS = XDR_PUT_UINT32(SELF, VALS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_BYTES_ARRAY(SELF, STRS, LENGTHS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), INTENT(IN) :: STRS
    INTEGER(KIND = C_SIZE_T), DIMENSION(:), INTENT(IN) :: LENGTHS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: LENGTH

    B = SELF%OFFSET
    LENGTH = MIN(SIZE(STRS), MAXSIZE)
    SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T))
    DO N = 1, LENGTH
      SUCCESS = XDR_PUT_BYTES(SELF, STRS(N), LENGTHS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

  FUNCTION XDR_PUT_STRING_ARRAY(SELF, STRS, MAXSIZE) RESULT(SUCCESS)
    CLASS(XDR_T) :: SELF
    CHARACTER(KIND = C_CHAR, LEN = *), DIMENSION(:), INTENT(IN) :: STRS
    INTEGER(KIND = C_SIZE_T), INTENT(IN) :: MAXSIZE
    LOGICAL :: SUCCESS

    INTEGER(KIND = C_SIZE_T) :: B
    INTEGER(KIND = C_SIZE_T) :: N
    INTEGER(KIND = C_SIZE_T) :: LENGTH

    B = SELF%OFFSET
    LENGTH = MIN(SIZE(STRS), MAXSIZE)
    SUCCESS = XDR_PUT_INT32(SELF, INT(LENGTH, KIND = C_INT32_T))
    DO N = 1, LENGTH
      SUCCESS = XDR_PUT_STRING(SELF, STRS(N))
      IF (.NOT. SUCCESS) THEN
        SELF%OFFSET = B
        EXIT
      END IF
    END DO
  END FUNCTION

END MODULE
